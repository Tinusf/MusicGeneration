from collections import defaultdict
from typing import Tuple
from collections import Counter
import numpy as np
from music21 import *
import os
import pickle
import config


def load_all_midi_files() -> np.ndarray:
    pickle_path = "midi_files_array.pickle"
    if (config.LOAD_CACHED_MIDI_FILES and os.path.exists(pickle_path)):
        return pickle.load(open(pickle_path, "br"))

    # Data downloaded from https://www.analyticsvidhya.com/blog/2020/01/how-to-perform-automatic-music-generation/
    path = config.MIDI_DIRECTORY
    files = [i for i in os.listdir(path) if i.endswith(".mid")]
    array = np.array([read_midi(path + i) for i in files])
    pickle.dump(array, open(pickle_path, "bw"))
    return array


# defining function to read MIDI files
def read_midi(file: str) -> np.ndarray:
    print("Loading Music File:", file)

    notes = []
    notes_to_parse = None

    # parsing a midi file
    midi = converter.parse(file)

    # grouping based on different instruments
    s2 = instrument.partitionByInstrument(midi)

    # a dictionary with key offset and value which note and instrument str. "pianoE3"
    # after this merge things into like: "pianoE3ViolinE1"
    notes = defaultdict(lambda: "")

    for part in s2.parts:
        # select elements of only piano
        if 'Piano' in str(part):
            notes_to_parse = part.recurse()
            # finding whether a particular element is note or a chord
            for element in notes_to_parse:
                totalOffset = element.getOffsetInHierarchy(midi)
                # note
                if isinstance(element, note.Note):
                    notes[totalOffset] += "piano" + str(element.pitch)
                # chord
                elif isinstance(element, chord.Chord):
                    notes[totalOffset] += "piano" + '.'.join(str(n) for n in element.normalOrder)
        elif "Violin" in str(part):
            notes_to_parse = part.recurse()
            # finding whether a particular element is note or a chord
            for element in notes_to_parse:
                totalOffset = element.getOffsetInHierarchy(midi)
                # note
                if isinstance(element, note.Note):
                    notes[totalOffset] += "violin" + str(element.pitch)
                # chord
                elif isinstance(element, chord.Chord):
                    notes[totalOffset] += "violin" + '.'.join(str(n) for n in element.normalOrder)

    output_notes = []
    for offset in sorted(notes):
        _note = notes[offset]
        output_notes.append(_note)

    return np.array(output_notes)


def get_frequency_dict(notes: np.ndarray) -> dict:
    # Flatten the notes array.
    notes_1d = [element for note_ in notes for element in note_]
    # Frequency dictionary.
    return dict(Counter(notes_1d))


def get_frequent_notes(notes: np.ndarray) -> list:
    freq = get_frequency_dict(notes)
    # Return the notes that have a count of 50 or above.
    return [note_ for note_, count in freq.items() if count >= 50]


def filter_frequent_notes(notes: np.ndarray, frequent_notes: list) -> np.ndarray:
    return np.array([[_note for _note in one_song if _note in frequent_notes] for one_song in notes])


def create_training_dataset(notes: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """
    This method creates a dataset containing 32 notes as input and a single note as output for those 32 notes.
    :param notes: Numpy array of notes.
    :return: X, y dataset.
    """
    no_of_timesteps = 32
    x = []
    y = []

    for _note in notes:
        for i in range(0, len(_note) - no_of_timesteps, 1):
            input_notes = _note[i:i + no_of_timesteps]
            output_note = _note[i + no_of_timesteps]

            x.append(input_notes)
            y.append(output_note)

    return np.array(x), np.array(y)


def convert_to_midi(prediction_output):
    offset = 0
    # dictionary with key being instrument and value being the notes.
    output_notes_piano = stream.Part()
    output_notes_violin = stream.Part()

    # create note and chord objects based on the values generated by the model
    for pattern in prediction_output:
        n_pianos = pattern.count("piano")
        n_violins = pattern.count("violin")
        diff = n_pianos - n_violins
        merge_to_chord = False
        to_be_merged = []
        if n_pianos > 0 and n_violins == 0:
            # Then we merge the pianos into a chord.
            diff = 1
            merge_to_chord = True
        elif n_violins > 0 and n_pianos == 0:
            diff = -1
            merge_to_chord = True

        while pattern != "":
            cur_instrument = None
            cur_instrument_str = ""
            if pattern.startswith("violin"):
                pattern = pattern.replace("violin", "", 1)
                cur_instrument = instrument.Violin()
                cur_instrument_str = "violin"
            elif pattern.startswith("piano"):
                pattern = pattern.replace("piano", "", 1)
                cur_instrument = instrument.Piano()
                cur_instrument_str = "piano"

            closest_i = 1000
            piano_i = pattern.find("piano")
            violin_i = pattern.find("violin")
            if piano_i > -1:
                closest_i = min(closest_i, piano_i)
            if violin_i > -1:
                closest_i = min(closest_i, violin_i)
            current_notes = pattern[0:closest_i]
            pattern = pattern.replace(current_notes, "", 1)

            # pattern is a chord
            if ('.' in current_notes) or current_notes.isdigit():
                notes_in_chord = current_notes.split('.')
                notes = []
                for current_note in notes_in_chord:
                    cn = int(current_note)
                    new_note = note.Note(cn)
                    new_note.offset = offset
                    new_note.storedInstrument = cur_instrument
                    if merge_to_chord:
                        to_be_merged.append(new_note)
                    else:
                        notes.append(new_note)

                new_chord = chord.Chord(notes)
                new_chord.offset = offset
                if cur_instrument_str == "piano":
                    if not merge_to_chord:
                        output_notes_piano.append(cur_instrument)
                        output_notes_piano.append(new_chord)
                    if diff > 0:
                        output_notes_violin.append(note.Rest())
                        diff -= 1
                else:
                    if not merge_to_chord:
                        output_notes_violin.append(cur_instrument)
                        output_notes_violin.append(new_chord)
                    if diff < 0:
                        output_notes_piano.append(note.Rest())
                        diff += 1

            # pattern is a note
            else:
                new_note = note.Note(current_notes)
                new_note.offset = offset
                new_note.storedInstrument = cur_instrument
                if cur_instrument_str == "piano":
                    if merge_to_chord:
                        to_be_merged.append(new_note)
                    else:
                        output_notes_piano.append(cur_instrument)
                        output_notes_piano.append(new_note)
                    if diff > 0:
                        output_notes_violin.append(note.Rest())
                        diff -= 1
                else:
                    if merge_to_chord:
                        to_be_merged.append(new_note)
                    else:
                        output_notes_violin.append(cur_instrument)
                        output_notes_violin.append(new_note)
                    if diff < 0:
                        output_notes_piano.append(note.Rest())
                        diff += 1

        if len(to_be_merged) > 0:
            new_chord = chord.Chord(to_be_merged)
            new_chord.offset = offset
            if cur_instrument_str == "piano":
                output_notes_piano.append(cur_instrument)
                output_notes_piano.append(new_chord)
            elif cur_instrument_str == "violin":
                output_notes_violin.append(cur_instrument)
                output_notes_violin.append(new_chord)
            else:
                raise ValueError("Instrument not supported.")

        offset += 1

    song = stream.Stream()

    # This was an attempt to fix that you can play both instruments at the same time, it doesn't work.
    for piano_note in output_notes_piano.notes:
        song.insert(piano_note.offset, piano_note)
        song.insert(piano_note.offset, instrument.Piano())

    for violin_note in output_notes_violin.notes:
        song.insert(violin_note.offset, violin_note)
        song.insert(violin_note.offset, instrument.Violin())

    # This however, works good. You can write out the piano and violin to differnet files and convert
    # them to mp3 using https://audio.online-convert.com/convert/midi-to-mp3.
    # And then combine the two mp3 using audacity.
    output_notes_piano.write('midi', fp='piano.mid')
    output_notes_violin.write('midi', fp='violin.mid')
    song = song.flat
    song.write('midi', fp='music.mid')
